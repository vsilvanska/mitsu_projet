'use strict';

var anchors = require('../doc/anchors.js');
var identity = require('../nodes/identity.js');
var stringifyComment = require('./stringifyComment.js');
var stringifyString = require('./stringifyString.js');

function createStringifyContext(doc, options) {
    var opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: 'PLAIN',
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: 'false',
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: 'null',
        simpleKeys: false,
        singleQuote: null,
        trueStr: 'true',
        verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    var inFlow;
    switch (opt.collectionStyle) {
        case 'block':
            inFlow = false;
            break;
        case 'flow':
            inFlow = true;
            break;
        default:
            inFlow = null;
    }
    return {
        anchors: new Set(),
        doc: doc,
        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',
        indent: '',
        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
        inFlow: inFlow,
        options: opt
    };
}
function getTagObject(tags, item) {
    if (item.tag) {
        var match = tags.filter(function (t) { return t.tag === item.tag; });
        if (match.length > 0)
            return match.find(function (t) { return t.format === item.format; }) || match[0];
    }
    var tagObj = undefined;
    var obj;
    if (identity.isScalar(item)) {
        obj = item.value;
        var match = tags.filter(function (t) { return t.identify && t.identify(obj); });
        tagObj =
            match.find(function (t) { return t.format === item.format; }) || match.find(function (t) { return !t.format; });
    }
    else {
        obj = item;
        tagObj = tags.find(function (t) { return t.nodeClass && obj instanceof t.nodeClass; });
    }
    if (!tagObj) {
        var name_1 = obj === null || obj === void 0 ? void 0 : obj.constructor.name || typeof obj;
        throw new Error("Tag not resolved for " + name_1 + " value");
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function stringifyProps(node, tagObj, _a) {
    var anchors$1 = _a.anchors, doc = _a.doc;
    if (!doc.directives)
        return '';
    var props = [];
    var anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push("&" + anchor);
    }
    var tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
    if (tag)
        props.push(doc.directives.tagString(tag));
    return props.join(' ');
}
function stringify(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
        if (ctx.doc.directives)
            return item.toString(ctx);
        if (ctx.resolvedAliases && ctx.resolvedAliases.has(item)) {
            throw new TypeError("Cannot stringify circular structure without alias nodes");
        }
        else {
            if (ctx.resolvedAliases)
                ctx.resolvedAliases.add(item);
            else
                ctx.resolvedAliases = new Set([item]);
            item = item.resolve(ctx.doc);
        }
    }
    var tagObj = undefined;
    var node = identity.isNode(item)
        ? item
        : ctx.doc.createNode(item, { onTagObj: function (o) { return (tagObj = o); } });
    if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
    var props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart !== null && ctx.indentAtStart !== void 0 ? ctx.indentAtStart : 0) + props.length + 1;
    var str = typeof tagObj.stringify === 'function'
        ? tagObj.stringify(node, ctx, onComment, onChompKeep)
        : identity.isScalar(node)
            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
    if (!props)
        return str;
    return identity.isScalar(node) || str[0] === '{' || str[0] === '['
        ? props + " " + str
        : props + "\n" + ctx.indent + str;
}

exports.createStringifyContext = createStringifyContext;
exports.stringify = stringify;
